initSidebarItems({"fn":[["calculate_intrinsic_gas","Calculate the intrinsic gas for the transaction based upon its size in bytes/words."],["instruction_key","The encoding of the instruction is the serialized form of it, but disregarding the serialization of the instruction's argument(s)."],["words_in","Computes the number of words rounded up"]],"struct":[["AbstractMemorySize","A newtype wrapper that represents the (abstract) memory size that the instruciton will take up."],["CONST_SIZE","The size in words for a non-string or address constant on the stack"],["CostTable","The cost tables, keyed by the serialized form of the bytecode instruction.  We use the serialized form as opposed to the instruction enum itself as the key since this will be the on-chain representation of bytecode instructions in the future."],["DEFAULT_ACCOUNT_SIZE","For V1 all accounts will be 32 words"],["GAS_SCHEDULE_NAME",""],["GLOBAL_MEMORY_PER_BYTE_COST","The cost per-byte written to global storage. TODO: Fill this in with a proper number once it's determined."],["GLOBAL_MEMORY_PER_BYTE_WRITE_COST","The cost per-byte written to storage. TODO: Fill this in with a proper number once it's determined."],["GasCost","The  `GasCost` tracks: - instruction cost: how much time/computational power is needed to perform the instruction - memory cost: how much memory is required for the instruction, and storage overhead"],["GasPrice","A newtype wrapper around the gas price for each unit of gas consumed."],["GasUnits","A newtype wrapper around the underlying carrier for the gas cost."],["INTRINSIC_GAS_PER_BYTE","The units of gas that should be charged per byte for every transaction."],["LARGE_TRANSACTION_CUTOFF","Any transaction over this size will be charged `INTRINSIC_GAS_PER_BYTE` per byte"],["MAXIMUM_NUMBER_OF_GAS_UNITS","1 nanosecond should equal one unit of computational gas. We bound the maximum computational time of any given transaction at 10 milliseconds. We want this number and `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that         MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits::MAX)"],["MAX_ABSTRACT_MEMORY_SIZE","The maximum size representable by AbstractMemorySize"],["MAX_PRICE_PER_GAS_UNIT","The maximum gas unit price that a transaction can be submitted with."],["MIN_PRICE_PER_GAS_UNIT","The minimum gas price that a transaction can be submitted with."],["MIN_TRANSACTION_GAS_UNITS","We charge one unit of gas per-byte for the first 600 bytes"],["REFERENCE_SIZE","The size in words for a reference on the stack"],["STRUCT_SIZE","The size of a struct in words"],["WORD_SIZE","The word size that we charge by"]],"trait":[["GasAlgebra","A trait encoding the operations permitted on the underlying carrier for the gas unit, and how other gas-related units can interact with other units -- operations can only be performed across units with the same underlying carrier (i.e. as long as the underlying data is the same)."]],"type":[["GasCarrier","The underlying carrier for gas-related units and costs. Data with this type should not be manipulated directly, but instead be manipulated using the newtype wrappers defined around them and the functions defined in the `GasAlgebra` trait."]]});