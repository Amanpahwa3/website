initSidebarItems({"mod":[["absint",""],["abstract_state","This module defines the abstract state for the type and memory safety analysis."],["acquires_list_verifier","This module implements a checker for verifying properties about the acquires list on function definitions. Function definitions must annotate the global resources (declared in that module) accesssed by `BorrowGlobal`, `MoveFrom`, and any transitive function calls The list of acquired resources (stored in `FunctionDefinition`'s `acquires_global_resources` field) must have: - No duplicate resources (checked by `check_duplication`) - No missing resources (any resource acquired must be present) - No additional resources (no extraneous resources not actually acquired)"],["borrow_graph","This module defines the (acyclic) borrow graph for the type and memory safety analysis. A node in the borrow graph represents an abstract reference.  Each edge in the borrow graph is labeled with a (possibly empty) sequence of label elements.  A label element is either a field index or a local index or a struct index.  An edge coming out of frame_root (see abstract_state.rs) is labeled with a sequence beginning with a local or struct index followed by zero or more field indices.  An edge coming out of a node different from frame_root is labeled by a sequence of zero or more field indices. An edge in the borrow graph from a node other than frame_root represents a prefix relationship between the references represented by the source and sink of the edge.  There are two kinds of edges---strong and weak.  A strong edge from node a to b labeled by sequence p indicates that b is equal to the p-extension of a.  Instead, if the edge was weak, it indicates that b is an extension of the p-extension of a."],["check_duplication","This module implements a checker for verifying that each vector in a CompiledModule contains distinct values. Successful verification implies that an index in vector can be used to uniquely name the entry at that index. Additionally, the checker also verifies the following: - struct and field definitions are consistent - the handles in struct and function definitions point to IMPLEMENTED_MODULE_INDEX - all struct and function handles pointing to IMPLEMENTED_MODULE_INDEX have a definition"],["code_unit_verifier","This module implements the checker for verifying correctness of function bodies. The overall verification is split between stack_usage_verifier.rs and abstract_interpreter.rs. CodeUnitVerifier simply orchestrates calls into these two files."],["control_flow_graph","This module defines the control-flow graph uses for bytecode verification."],["instantiation_loops","This implements an algorithm that detects loops during the instantiation of generics."],["nonce","This module implements the Nonce type used for borrow checking in the abstract interpreter. A Nonce instance represents an arbitrary reference or access path. The integer inside a Nonce is meaningless; only equality and borrow relationships are meaningful."],["resources","This module implements a checker for verifying that a non-resource struct does not have resource fields inside it."],["signature","This module implements a checker for verifying signature tokens used in types of function parameters, locals, and fields of structs are well-formed. References can only occur at the top-level in all tokens.  Additionally, references cannot occur at all in field types."],["stack_usage_verifier","This module implements a checker for verifying that basic blocks in the bytecode instruction sequence of a function use the evaluation stack in a balanced manner. Every basic block, except those that end in Ret (return to caller) opcode, must leave the stack height the same as at the beginning of the block. A basic block that ends in Ret opcode must increase the stack height by the number of values returned by the function as indicated in its signature. Additionally, the stack height must not dip below that at the beginning of the block for any basic block."],["struct_defs","This module provides a checker for verifing that struct definitions in a module are not recursive. Since the module dependency graph is acylic by construction, applying this checker to each module in isolation guarantees that there is no structural recursion globally."],["type_memory_safety","This module defines the transfer functions for verifying type and memory safety of a procedure body."],["unused_entries",""],["verifier","This module contains the public APIs supported by the bytecode verifier."]]});