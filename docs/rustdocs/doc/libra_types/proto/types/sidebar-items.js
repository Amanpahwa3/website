initSidebarItems({"mod":[["request_item",""],["response_item",""],["transaction_argument",""]],"struct":[["AccessPath",""],["AccountState","Account state as a whole. After execution, updates to accounts are passed in this form to storage for persistence."],["AccountStateBlob",""],["AccountStateProof","The complete proof used to authenticate an account state."],["AccountStateWithProof",""],["AccumulatorConsistencyProof",""],["AccumulatorProof",""],["AccumulatorRangeProof",""],["Event","An event emitted from a smart contract"],["EventProof","The complete proof used to authenticate an event."],["EventWithProof","An event along with the proof for the event"],["EventsForVersions","A list of EventList's, each representing all events for a transaction."],["EventsList","A list of events."],["GetAccountStateRequest","Gets latest state for an account."],["GetAccountStateResponse","State information returned by a get account state query."],["GetAccountTransactionBySequenceNumberRequest","----------------------------------------------------------------------------- ---------------- Get single transaction by account + sequence number ----------------------------------------------------------------------------- Get transactions that altered an account - this includes both sent and received. A user of this should check that the data returned matches what they expect.  As an example, a potential attack vector would be something like the following: Alice is buying an apple from Bob. Alice's phone signs a transaction X with sequence number N that pays coins to Bob. Alice transmits this signature to Bob's payment terminal which then submits the transaction and checks its status to see if Alice can be given the apple. However, as Bob is doing this Alice constructs a second transaction X' also with sequence number N. Alice gets that transaction inserted in the blockchain. If Bob isn't thoughtful about how he uses this API he may assume that if he asks for the N'th transaction on Alice's account that when the API returns that this means the transaction has gone through. The point here is that one should be careful in reading too much into \"transaction X is on the chain\" and focus on the logs, which tell you what the transaction did."],["GetAccountTransactionBySequenceNumberResponse","Transaction information for transactions requested by GetAccountTransactionsRequest"],["GetEventsByEventAccessPathRequest","Get events that exist on an event access path.  In the current world, a user may specify events that were received, events that were sent, or any event that modifies their account"],["GetEventsByEventAccessPathResponse",""],["GetTransactionsRequest","Get up to limit transactions starting from start_version."],["GetTransactionsResponse",""],["LedgerInfo",""],["LedgerInfoWithSignatures",""],["ModuleId",""],["RequestItem",""],["ResponseItem","Individual response items to the queries posed by the requests"],["SignedTransaction","A generic structure that represents signed RawTransaction"],["SignedTransactionsBlock","A generic structure that represents a block of transactions originated from a particular validator instance."],["SparseMerkleProof",""],["Transaction","A generic structure that represents a transaction, covering all possible variants."],["TransactionArgument","An argument to the transaction if the transaction takes arguments"],["TransactionInfo","`TransactionInfo` is the object we store in the transaction accumulator. It consists of the transaction as well as the execution result of this transaction. This are later returned to the client so that a client can validate the tree"],["TransactionListProof","The complete proof used to authenticate a list of transactions."],["TransactionListWithProof","A list of consecutive transactions with proof. This is mainly used for state synchronization when a validator would request a list of transactions from a peer, verify the proof, execute the transactions and persist them. Note that the transactions are supposed to belong to the same epoch E, otherwise verification will fail."],["TransactionProof","The complete proof used to authenticate a transaction."],["TransactionToCommit","Transaction struct to commit to storage"],["TransactionWithProof",""],["UpdateToLatestLedgerRequest","This API is used to update the client to the latest ledger version and optionally also request 1..n other pieces of data.  This allows for batch queries.  All queries return proofs that a client should check to validate the data."],["UpdateToLatestLedgerResponse","Response from getting latest ledger"],["ValidatorChangeEventWithProof","This is used to prove validator changes.  When a validator is changing, it triggers an event on /validator_change_account/events/sent.  To tell the client about validator changes, we query /validator_change_account/events/sent to get all versions that contain validator changes after the version that we are trying to update from. For each of these versions, the old validator set would have signed the ledger info at that version.  The client needs this as well as the event results + proof.  The client can then verify that these events were under the current tree and that the changes were signed by the old validators (and that the events correctly show which validators are the new validators)."],["ValidatorPublicKeys","Protobuf definition for the Rust struct ValidatorPublicKeys"],["ValidatorSet","Protobuf definition for the Rust struct ValidatorSet."],["ValidatorSignature",""],["VmStatus","The statuses and errors produced by the VM can be categorized into a couple different types: 1. Validation Statuses: all the errors that can (/should) be    the result of executing the prologue -- these are primarily used by    the vm validator and AC. 2. Verification Errors: errors that are the result of performing    bytecode verification (happens at the time of publishing). 3. VM Invariant Errors: errors that arise from an internal invariant of    the VM being violated. These signify a problem with either the VM or    bytecode verifier. 4. Binary Errors: errors that can occur during the process of    deserialization of a transaction. 5. Runtime Statuses: errors that can arise from the execution of a    transaction (assuming the prologue executes without error). These are    errors that can occur during execution due to things such as division    by zero, running out of gas, etc. These do not signify an issue with    the VM."]]});